静态库和动态库的区别
2009-02-14 05:08
文件预览
文件目录树如下，如你所见，非常简单。
   1. libtest/ 
   2. |-- lt.c 
   3. |-- lt.h 
   4. `-- test.c 
代码
#lt.c
   1. /* lt.c 
   2. * 
   3. */ 
   4.   
   5. #include   
   6.   
   7. void myprint(void) 
   8. { 
   9.   printf("Linux library test!\n"); 
10. } 

# lt.h
   1. /* lt.h 
   2. * 
   3. */ 
   4.   
   5. void myprint(void); 

#test.c
   1. /* test.c 
   2. * 
   3. */ 
   4.   
   5. #include "lt.h" 
   6.   
   7. int main(void) 
   8. { 
   9.   myprint(); 
10.   return 0; 
11. } 


先看静态库
首先做成静态库 liblt.a 。
   1. $ gcc -o lt.o -c lt.c
   2. $ ar cqs liblt.a lt.o

再者，链接，
   1. $ gcc test.o liblt.a -o test 

这个时候再来看他的引用库情况。
   1. $ ldd test 
   2.         linux-gate.so.1 => (0xffffe000) 
   3.         libc.so.6 => /lib/libc.so.6 (0xb7e29000) 
   4.         /lib/ld-linux.so.2 (0xb7f6e000) 

动态库
做成动态库 liblt.so 。
   1. $ gcc -o lt.o -c lt.c 
   2. $ gcc -shared -Wall -fPIC -o liblt.so lt.o   

-shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。

-L.：表示要连接的库在当前目录中
-ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称
LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。

链接方法I，拷贝到系统库里再链接，让gcc自己查找

   1. $ sudo cp liblt.so /usr/lib 
   2. $ gcc -o test test.o -llt 
这里我们可以看到了 -llt 选项，-l[lib_name] 指定库名，他会主动搜索
lib[lib_name].so。这个搜索的路径可以通过 gcc --print-search-dirs来查找。

链接方法II，手动指定库路径

   1. $ cc -o test test.o -llt -B /path/to/lib
这里的-B 选项就添加 /path/to/lib 到gcc搜索的路径之中。这样链接没有问题但是方法II中手动链接好的程序在执行时候仍旧需要指定库路径（链接和执行是分开的）。需要添加系
统变量 LD_LIBRARY_PATH :

   1. $ export LD_LIBRARY_PATH=/path/to/lib 

这个时候再来检测一下test程序的库链接状况(方法I情况)
   1. $ ldd test 
   2.         linux-gate.so.1 => (0xffffe000) 
   3.         liblt.so => /usr/lib/liblt.so (0xb7f58000) 
   4.         libc.so.6 => /lib/libc.so.6 (0xb7e28000) 
   5.         /lib/ld-linux.so.2 (0xb7f6f000) 

恩，是不是比静态链接的程序多了一个 liblt.so ？恩，这就是静态与动态的最大区别，静态情况下，他把库直接加载到程序里，而在动态链接的时候，他只是保留接口，将动态库与程序代码独立。这样就可以提高代码的可复用度，和降低程序的耦合度。
另外，运行时，要保证主程序能找到动态库，所以动态库一般发布到系统目录中，要么就在跟主程序相对很固定的路径里，这样不管主程序在本机何时何地跑，都能找得到动态库。而静态库只作用于链接时，运行主程序时，静态库文件没存在意义了。


－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
Linux中有两类函数库，分别是静态库和动态库。 

静态函数库： 

这类库的名字一般是libxxx.a；利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了， 即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必 须重新编译。 

动态函数库： 

这类库的名字一般是libxxx.so;相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数 库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须 提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 

linux系统有几个重要的目录存放相应的函数库，如/lib /usr/lib。 

下面来介绍linux静态函数库的创建和使用： 

例程str_out.h str_out.c main.c: 

str_out.h 

#ifndef STR_OUT_H 

#define STR_OUT_H 

void str_out(const char* str); 

#endif 

str_out.c 

#include 

#include "str_out.h" 

void str_out(const char* str){ 

printf("%s\n",str); 

} 

main.c 

int main() 

{ 

str_out("hello world"); 

return 0; 

} 

不管是静态函数库还是动态函数库，都是由*.o目标文件生成。 

所以先gcc -c str_out.c 

静态函数库由ar命令创建 

本例：ar -cr libstr_out.a str_out.o 

-c create的意思 

-r replace的意思，表示当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 

到此静态函数库创建完毕。 

使用方法：通过gcc -o out main.c -L. -lstr_out编译main.c就会把静态函数库整合进out。 

其中 

-L指定静态函数库的位置供查找，注意L后面还有'.'，表示静态函数库在本目录下查找。 

-l则指定了静态函数库名，由于静态函数库的命名方式是lib***.a，其中的lib和.a忽略。 

根据静态函数库的特性，此处删除libstr_out.a后out依然可以运行，因为静态库的内容已经整合进去了。 

动态函数库的创建和使用 

gcc -shared -fPCI -o out main.c -L. -lstr_out 

用该命令生成libstr_out.so 动态函数库。 

gcc -o out main.c 

此时还不能立即./out，因为在动态函数库使用时，会查找/usr/lib /lib目录下的动态函数库，而此时我们生成的库不在里边。 

这个时候有好几种方法可以让他成功运行： 

最直接最简单的方法就是把libstr_out.so拉到/usr/lib 或/lib中去。 

还有一种方法 export LD_LIBRARY_PATH=$(pwd) 

另外还可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig。 

/etc/ld.so.conf是非常重要的一个目录，里面存放的是链接器和加载器搜索共享库时要检查的目录，默认是从/usr/lib /lib中读取的，所以想要顺利运行，我们也可以把我们库的目录加入到这个文件中并执行/sbin/ldconfig 

另外还有个文件需要了解/etc/ld.so.cache,里面保存了常用的动态函数库，且会先把他们加载到内存中，因为内存的访问速度远远大于硬盘的访问速度，这样可以提高软件加载动态函数库的速度了。

***************************windows和linux下动态库的区别****************************************************************
摘要：动态链接库技术实现和设计程序常用的技术，在Windows和Linux系统中都有动态库的概念，采用动态库可以有效的减少程序大小，节省空间，提高效率，增加程序的可扩展性，便于模块化管理。但不同操作系统的动态库由于格式不同，在需要不同操作系统调用时需要进行动态库程序移植。本文分析和比较了两种操作系统动态库技术，并给出了将Visual C++编制的动态库移植到Linux上的方法和经验。
关键词：动态链接库 Linux编程 程序移植
1 引言
动 态库（Dynamic Link Library abbr，DLL）技术是程序设计中经常采用的技术。其目的减少程序的大小，节省空间，提高效率，具有很高的灵活性。采用动态库技术对于升级软件版本更加 容易。与静态库（Static Link Library）不同，动态库里面的函数不是执行程序本身的一部分，而是根据执行需要按需载入，其执行代码可以同时在多个程序中共享。
在 Windows和Linux操作系统中，都可采用这种方式进行软件设计，但他们的调用方式以及程序编制方式不尽相同。本文首先分析了在这两种操作系统中通 常采用的动态库调用方法以及程序编制方式，然后分析比较了这两种方式的不同之处，最后根据实际移植程序经验，介绍了将VC++编制的Windows动态库 移植到Linux下的方法。
2 动态库技术
2.1 Windows动态库技术
动 态链接库是实现Windows应用程序共享资源、节省内存空间、提高使用效率的一个重要技术手段。常见的动态库包含外部函数和资源，也有一些动态库只包含 资源，如Windows字体资源文件，称之为资源动态链接库。通常动态库以.dll，.drv、.fon等作为后缀。相应的windows静态库通常 以.lib结尾，Windows自己就将一些主要的系统功能以动态库模块的形式实现。
Windows 动态库在运行时被系统加载到进程的虚拟空间中，使用从调用进程的虚拟地址空间分配的内存，成为调用进程的一部分。DLL也只能被该进程的线程所访问。 DLL的句柄可以被调用进程使用；调用进程的句柄可以被DLL使用。DLL模块中包含各种导出函数，用于向外界提供服务。DLL可以有自己的数据段，但没 有自己的堆栈，使用与调用它的应用程序相同的堆栈模式；一个DLL在内存中只有一个实例；DLL实现了代码封装性；DLL的编制与具体的编程语言及编译器 无关，可以通过DLL来实现混合语言编程。DLL函数中的代码所创建的任何对象（包括变量）都归调用它的线程或进程所有。
根据调用方式的不同，对动态库的调用可分为静态调用方式和动态调用方式。
(1) 静态调用，也称为隐式调用，由编译系统完成对DLL的加载和应用程序结束时DLL卸载的编码（Windows系统负责对DLL调用次数的计数），调用方式 简单，能够满足通常的要求。通常采用的调用方式是把产生动态连接库时产生的.LIB文件加入到应用程序的工程中，想使用DLL中的函数时，只须在源文件中 声明一下。 LIB文件包含了每一个DLL导出函数的符号名和可选择的标识号以及DLL文件名，不含有实际的代码。Lib文件包含的信息进入到生成的应用程序中，被调 用的DLL文件会在应用程序加载时同时加载在到内存中。
(2)动态调用，即显式调用方式，是由编程者用API函数加载和卸载DLL来达到调用DLL的目的，比较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。在Windows系统中，与动态库调用有关的函数包括：
①LoadLibrary（或MFC 的AfxLoadLibrary），装载动态库。
②GetProcAddress，获取要引入的函数，将符号名或标识号转换为DLL内部地址。
③FreeLibrary（或MFC的AfxFreeLibrary），释放动态链接库。
在 windows中创建动态库也非常方便和简单。在Visual C++中，可以创建不用MFC而直接用C语言写的DLL程序，也可以创建基于MFC类库的DLL程序。每一个DLL必须有一个入口点，在VC++ 中，DllMain是一个缺省的入口函数。DllMain负责初始化(Initialization)和结束(Termination)工作。动态库输出 函数也有两种约定，分别是基于调用约定和名字修饰约定。DLL程序定义的函数分为内部函数和导出函数，动态库导出的函数供其它程序模块调用。通常可以有下 面几种方法导出函数：
①采用模块定义文件的EXPORT部分指定要输入的函数或者变量。
②使用MFC提供的修饰符号_declspec(dllexport)。
③以命令行方式，采用/EXPORT命令行输出有关函数。
在windows动态库中，有时需要编写模块定义文件(.DEF)，它是用于描述DLL属性的模块语句组成的文本文件。
2 Linux共享对象技术
在Linux操作系统中，采用了很多共享对象技术（Shared Object），虽然它和Windows里 的动态库相对应，但它并不称为动态库。相应的共享对象文件以.so作为后缀，为了方便，在本文中，对该概念不进行专门区分。Linux系统的/lib以及 标准图形界面的/usr/X11R6/lib等目录里面，就有许多以so结尾的共享对象。同样，在Linux下，也有静态函数库这种调用方式，相应的后缀 以.a结束。Linux采用该共享对象技术以方便程序间共享，节省程序占有空间，增加程序的可扩展性和灵活性。Linux还可以通过LD-PRELOAD 变量让开发人员可以使用自己的程序库中的模块来替换系统模块。
同Windows系统 一样，在Linux中创建和使用动态库是比较容易的事情，在编译函数库源程序时加上-shared选项即可，这样所生成的执行程序就是动态链接库。通常这 样的程序以so为后缀，在Linux动态库程序设计过程中，通常流程是编写用户的接口文件，通常是.h文件，编写实际的函数文件，以.c或.cpp为后 缀，再编写makefile文件。对于较小的动态库程序可以不用如此，但这样设计使程序更加合理。
编 译生成动态连接库后，进而可以在程序中进行调用。在Linux中，可以采用多种调用方式，同Windows的系统目录(..\system32等)一样， 可以将动态库文件拷贝到/lib目录或者在/lib目录里面建立符号连接，以便所有用户使用。下面介绍Linux调用动态库经常使用的函数，但在使用动态 库时，源程序必须包含dlfcn.h头文件，该文件定义调用动态链接库的函数的原型。
(1)_打开动态链接库：dlopen，函数原型void *dlopen (const char *filename, int flag);
dlopen用于打开指定名字(filename)的动态链接库，并返回操作句柄。
(2)取函数执行地址：dlsym，函数原型为: void *dlsym(void *handle, char *symbol);
dlsym根据动态链接库操作句柄(handle)与符号(symbol)，返回符号对应的函数的执行代码地址。
(3)关闭动态链接库：dlclose ，函数原型为: int dlclose (void *handle);
dlclose 用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。 (4)动态库错误函数：dlerror，函数原型为: const char *dlerror(void); 当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回值为NULL时表示操作函数执行成功。
在取到函数执行地址后，就可以在动态库的使用程序里面根据动态库提供的函数接口声明调用动态库里面的函数。在编写调用动态库的程序的makefile文件时，需要加入编译选项-rdynamic和-ldl。
除 了采用这种方式编写和调用动态库之外，Linux操作系统也提供了一种更为方便的动态库调用方式，也方便了其它程序调用，这种方式与Windows系统的 隐式链接类似。其动态库命名方式为“lib*.so.*”。在这个命名方式中，第一个*表示动态链接库的库名，第二个*通常表示该动态库的版本号，也可以 没有版本号。在这种调用方式中，需要维护动态链接库的配置文件/etc/ld.so.conf来让动态链接库为系统所使用，通常将动态链接库所在目录名追 加到动态链接库配置文件中。如具有X window窗口系统发行版该文件中都具有/usr/X11R6/lib，它指向X window窗口系统的动态链接库所在目录。为了使动态链接库能为系统所共享，还需运行动态链接库的管理命令./sbin/ldconfig。在编译所引用的动态库时，可以在gcc采用 Cl或-L选项或直接引用所需的动态链接库方式进行编译。在Linux里面，可以采用ldd命令来检查程序依赖共享库。
3 两种系统动态库比较分析
Windows和Linux采用动态链接库技术目的是基本一致的，但由于操作系统的不同，他们在许多方面还是不尽相同，下面从以下几个方面进行阐述。
(1) 动态库程序编写，在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数作为初始化的人口，通常在导出函数的声明时需要有 _declspec(dllexport)关键字。Linux下的gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要到函数做特别声明， 编写比较方便。
(2)动态库编译，在windows系统下面，有方便的调试编译环境，通常不用自己去编写makefile文件，但在linux下面，需要自己动手去编写makefile文件，因此，必须掌握一定的makefile编写技巧，另外，通常Linux编译规则相对严格。
(3)动态库调用方面，Windows和Linux对其下编制的动态库都可以采用显式调用或隐式调用，但具体的调用方式也不尽相同。
(4) 动态库输出函数查看，在Windows中，有许多工具和软件可以进行查看DLL中所输出的函数，例如命令行方式的dumpbin以及VC++工具中的 DEPENDS程序。在Linux系统中通常采用nm来查看输出函数，也可以使用ldd查看程序隐式链接的共享对象文件。
(5)对操作系统的依赖，这两种动态库运行依赖于各自的操作系统，不能跨平台使用。因此，对于实现相同功能的动态库，必须为两种不同的操作系统提供不同的动态库版本。

